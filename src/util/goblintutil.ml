(** Globally accessible flags and utility functions. *)

open GoblintCil
open GobConfig


(** Outputs information about what the goblin is doing *)
(* let verbose = ref false *)

(** If this is true we output messages and collect accesses.
    This is set to true in control.ml before we verify the result (or already before solving if warn = 'early') *)
let should_warn = ref false

(** Whether signed overflow or underflow happened *)
let svcomp_may_overflow = ref false

(** The file where everything is output *)
let out = ref stdout

(** Command for assigning an id to a varinfo. All varinfos directly created by Goblint should be modified by this method *)
let create_var (var: varinfo) =
  (* TODO Hack: this offset should preempt conflicts with ids generated by CIL *)
  let start_id = 10_000_000_000 in
  let hash = Hashtbl.hash { var with vid = 0 } in
  let hash = if hash < start_id then hash + start_id else hash in
  { var with vid = hash }

(* Type invariant variables. *)
let type_inv_tbl = Hashtbl.create 13
let type_inv (c:compinfo) : varinfo =
  try Hashtbl.find type_inv_tbl c.ckey
  with Not_found ->
    let i = create_var (makeGlobalVar ("{struct "^c.cname^"}") (TComp (c,[]))) in
    Hashtbl.add type_inv_tbl c.ckey i;
    i

let is_blessed (t:typ): varinfo option =
  let me_gusta x = List.mem x (get_string_list "exp.unique") in
  match unrollType t with
  | TComp (ci,_) when me_gusta ci.cname -> Some (type_inv ci)
  | _ -> (None : varinfo option)


(** A hack to see if we are currently doing global inits *)
let global_initialization = ref false

(** Another hack to see if earlyglobs is enabled *)
let earlyglobs = ref false

(** Whether currently in postsolver evaluations (e.g. verify, warn) *)
let postsolving = ref false

(* None if verification is disabled, Some true if verification succeeded, Some false if verification failed *)
let verified : bool option ref = ref None


let vars = ref 0
let evals = ref 0
let narrow_reuses = ref 0


let rec for_all_in_range (a, b) f =
  let module BI = IntOps.BigIntOps in
  if BI.compare a b > 0
  then true
  else f a && (for_all_in_range (BI.add a (BI.one), b) f)

let dummy_obj = Obj.repr ()

let jobs () =
  match get_int "jobs" with
  | 0 -> Cpu.numcores ()
  | n -> n

(** call [f], with [r] temporarily set to [x] *)
let with_ref r x =
  let x0 = !r in
  r := x;
  Fun.protect ~finally:(fun () -> r := x0)
